-- test script for ELua/Lunatic Interpreter

--do return end

print('---=== ELua Test script ===---')

local function printf(fmt, ...)
    print(string.format(fmt, ...))
end

local function checkfail(funcstr)
    local status, res = pcall(DBG_.loadstring(funcstr))
    if (status) then
        print('ERROR: '..funcstr.." DIDN'T fail")
    else
        print('SUCCESS: '..funcstr.." failed: "..res)
    end
end


---- check serialization ----
gamevar("ourvar")
gamevar("ourvar2")

-- test nans, infs, precision, subnorms, booleans
ourvar2 = { "asd"; 0/0, 1/0, -1/0, 0.12345678901234567, 1e-314, true }
ourvar = { ourvar2; 1, 2, 3, "qwe"; [true]=0, [false]=1 }
ourvar[#ourvar+1] = ourvar;

local gvstr = DBG_.serializeGamevars()
ourvar = -1

print("========== attempting to load string: ==========")
print(gvstr)
print("---------- (end string to load) ----------")

-- XXX: need to think about fully restoring state
DBG_.loadGamevarsString(gvstr)
print("ourvar[4]="..ourvar[4])


local i

print('tweaking sector pals')
print('numsectors: ' .. gv.numsectors .. ' of ' .. gv.MAXSECTORS)

---[[
for i = 0, gv.numsectors/2 do
    sector[i].floorpal = 1;
    sector[i].ceilingpal = 2;
end

checkfail('gv.sprite[0].yrepeat = 100')  -- direct gv array access forbidden

local vol, lev
vol, lev = TEMP_getvollev()
print('volume='..vol..', level='..lev)

if (vol==1 and lev==1) then  -- E1L1
    print('tweaking some sprites 2')
    i = 562
    spriteext[i].alpha = 0.5;
    sprite[i].cstat = bit.bor(sprite[i].cstat, 2+512);
    spriteext[i].pitch = 128;
    spriteext[i].roll = 256;

    for spr in spritesofsect(307) do  -- some fence sprites in E1L1
        print('spr', spr)
        sprite[spr].pal = 6
    end
    for spr in spritesofsect(236) do
        print('#spr', spr)
    end

    --this is a problem
    --actor = {}
    actor[562].flags = bit.bor(actor[562].flags, 2);   -- pal 6 with goggles on front SEENINE
end

if (vol==1 and lev==8) then
    print('tweaking bunch 1');
    -- trueror1.map
    for i in sectorsofbunch(1, gv.CEILING) do
        sector[i].ceilingz = sector[i].ceilingz - 3*1024;
    end
    for i in sectorsofbunch(1, gv.FLOOR) do
        sector[i].floorz = sector[i].floorz - 3*1024;
    end
end

--]]
--DBG_.printkv('_G in test.elua', _G)

checkfail('local i = sprite["qwe"]')  -- indexing struct array with non-numeric type
checkfail('print(sprite[100000].ceilingpal)')  -- oob read access
checkfail('setmetatable(sprite, {})')  -- set metatable forbidden
checkfail('sector[-1].ceilingpal = 4')  -- oob write access
checkfail('sector[0].wallnum = 0')  -- wallnum member is read-only
checkfail('gv.numsectors = 4')  -- gv.numsectors is read-only
checkfail('gv.QWE = 4')  -- cannot create new fields in 'gv'
checkfail('sector[4] = sector[6]')  -- direct sector write access forbidden
checkfail('nextspritesect[4] = -666')  -- that would be horrible...
checkfail('print(nextspritesect[4].whatfield)')  -- we're indexing a plain array!
checkfail('wall[4].QWE = 123')  -- creating new keys forbidden... handled by LuaJit
checkfail("require('os')")  -- 'require' has been thrown away to be replaced by
                            -- something more restricted later
checkfail("new_global = 345")  -- we should declare globals
checkfail('gv.CEILING = 3')  -- can't redefine constants in 'gv'
checkfail('string.dump(gameevent)')  -- string.dump is unavailable

-- This is problematic, even though pretty much every access will yield a
-- "missing declaration" error.
-- See http://luajit.org/ext_ffi_api.html#ffi_C about what stuff ffi.C contains.
checkfail('gv.luaJIT_setmode(nil, 0, 0)')
checkfail('gv.luaJIT_BC_con_lang')
checkfail('gv.yax_getbunch(0,0)')
-- we don't have arrays in Lua-accessible structs now
checkfail('local i = actor[0].t_data[15]')

printf('ceilingbunch of sector 0: %d', getbunch(0, gv.CEILING))

gameevent(gv.EVENT_JUMP,
          function(actori, playeri, dist)
              printf("jump i=%d p=%d d=%d", actori, playeri, dist)
          end
         )

gameevent(gv.EVENT_ENTERLEVEL,
          function()
              -- NOTE: times are for helixhorned (Core2Duo 3GHz)
              local i
              local N = 1e6
              local t = gv.gethitickms()

              for i=3,N do
                  gv.gethitickms()
              end

              t = gv.gethitickms()-t

              -- x86: 40ns/call, x86_64: 290 ns/call
              printf("%d gethitickms() calls took %.03f ms (%.03f us/call)",
                     N, t, (t*1000)/N)

              local sum=0
              t = gv.gethitickms()
              for i=1,N do sum = sum+gv.ksqrt(i) end
              t = gv.gethitickms()-t
              -- x86_64: 14ns/call
              printf("%d ksqrt() calls took %.03f ms (%.03f us/call) [sum=%f]",
                     N, t, (t*1000)/N, sum)

              sum=0
              t = gv.gethitickms()
              for i=1,N do sum = sum+math.sqrt(i) end
              t = gv.gethitickms()-t
              -- x86_64: 7ns/call
              printf("%d math.sqrt() calls took %.03f ms (%.03f us/call) [sum=%f]",
                     N, t, (t*1000)/N, sum)

              printf("sqrt(0xffffffff) = %f(ksqrt) %f(math.sqrt)",
                     gv.ksqrt(0xffffffff), math.sqrt(0xffffffff))
          end
         )

gameactor(1680,  -- LIZTROOP
          function(i, playeri, dist)
              sprite[i].pal = math.random(32)
--              sprite[i].ang = bit.band(sprite[i].ang-20, 2047)

              local spr = sprite[i]
--              print(type(spr)) --> cdata
              assert(pcall("print(spr+1)") == false)  -- no ptr arith!

              local x,y,z = spr.x, spr.y, spr.z
              local t = gv.gethitickms()
              local hit = hitscan(x,y,z, spr.sectnum, 10, 10, 0, gv.CLIPMASK0)
              printf("hitscan took %.03f us, sec=%d, wal=%d, spr=%d", 1000*(gv.gethitickms()-t),
                    hit.hitsect, hit.hitwall, hit.hitsprite)
          end
         )

checkfail('gameactor(1680, 0)')  -- lua function expected, number passed
printf("EVENT_INIT = %d", gv.EVENT_INIT)  -- tests default defines

print('---=== END TEST SCRIPT ===---')
